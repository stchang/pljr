@inproceedings{Kohlbecker1986Hygienic,
    abstract = {Note: OCR errors may be found in this Reference List extracted from the full text article.  ACM has opted to expose the complete List rather than only correct and linked references.},
    address = {New York, NY, USA},
    author = {Kohlbecker, Eugene and Friedman, Daniel P. and Felleisen, Matthias and Duba, Bruce},
    booktitle = {LFP '86: Proceedings of the 1986 ACM conference on LISP and functional programming},
    citeulike-article-id = {1345},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=319859},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/319838.319859},
    doi = {10.1145/319838.319859},
    isbn = {0-89791-200-4},
    keywords = {macros, *pljr, *pljr-macros},
    location = {Cambridge, Massachusetts, United States},
    pages = {151--161},
    posted-at = {2010-10-18 03:55:45},
    priority = {0},
    publisher = {ACM},
    title = {Hygienic macro expansion},
    url = {http://dx.doi.org/10.1145/319838.319859},
    year = {1986}
}

@inproceedings{Kohlbecker1987Macrobyexample,
    abstract = {This paper presents two new developments. First, it describes a \&ldquo;macro-by-example\&rdquo; specification language for syntactic abstractions in Lisp and related languages. This specification language allows a more declarative specification of macros than conventional macro facilities do by giving a better treatment of iteration and mapping constructs. Second, it gives a formal semantics for the language and a derivation of a compiler from the semantics. This derivation is a practical application of semantics-directed compiler development methodology.},
    address = {New York, NY, USA},
    author = {Kohlbecker, E. E. and Wand, M.},
    booktitle = {POPL '87: Proceedings of the 14th ACM SIGACT-SIGPLAN symposium on Principles of programming languages},
    citeulike-article-id = {190436},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=41632},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/41625.41632},
    doi = {10.1145/41625.41632},
    isbn = {0-89791-215-2},
    keywords = {macros, *pljr, *pljr-macros},
    location = {Munich, West Germany},
    pages = {77--84},
    posted-at = {2010-10-18 04:05:52},
    priority = {0},
    publisher = {ACM},
    title = {Macro-by-example: Deriving syntactic transformations from their specifications},
    url = {http://dx.doi.org/10.1145/41625.41632},
    year = {1987}
}

@inproceedings{Bawden1988Syntactic,
    abstract = {In this paper we describe  syntactic closures . Syntactic closures address the scoping problems that arise when writing macros. We discuss some issues raised by introducing syntactic closures into the macro expansion interface, and we compare syntactic closures with other approaches. Included is a complete implementation.},
    address = {New York, NY, USA},
    author = {Bawden, Alan and Rees, Jonathan},
    booktitle = {LFP '88: Proceedings of the 1988 ACM conference on LISP and functional programming},
    citeulike-article-id = {1349},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=62687},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/62678.62687},
    doi = {10.1145/62678.62687},
    isbn = {0-89791-273-X},
    keywords = {macros, *pljr, *pljr-macros},
    location = {Snowbird, Utah, United States},
    pages = {86--95},
    posted-at = {2010-10-18 03:57:35},
    priority = {0},
    publisher = {ACM},
    title = {Syntactic closures},
    url = {http://dx.doi.org/10.1145/62678.62687},
    year = {1988}
}

@inproceedings{Clinger1991Macros,
    abstract = {Note: OCR errors may be found in this Reference List extracted from the full text article.  ACM has opted to expose the complete List rather than only correct and linked references.},
    address = {New York, NY, USA},
    author = {Clinger, William and Rees, Jonathan},
    booktitle = {POPL '91: Proceedings of the 18th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    citeulike-article-id = {1163},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=99607},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/99583.99607},
    doi = {10.1145/99583.99607},
    isbn = {0-89791-419-8},
    keywords = {macros, *pljr, *pljr-macros},
    location = {Orlando, Florida, United States},
    pages = {155--162},
    posted-at = {2010-10-18 03:59:13},
    priority = {0},
    publisher = {ACM},
    title = {Macros that work},
    url = {http://dx.doi.org/10.1145/99583.99607},
    year = {1991}
}

@article{Dybvig1992Syntactic,
    address = {Hingham, MA, USA},
    author = {Dybvig, R. Kent and Hieb, Robert and Bruggeman, Carl},
    citeulike-article-id = {162160},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=173620},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/BF01806308},
    doi = {10.1007/BF01806308},
    issn = {0892-4635},
    journal = {Lisp Symb. Comput.},
    keywords = {macros, *pljr, *pljr-macros},
    month = {December},
    number = {4},
    pages = {295--326},
    posted-at = {2010-10-18 04:00:20},
    priority = {0},
    publisher = {Kluwer Academic Publishers},
    title = {Syntactic abstraction in Scheme},
    url = {http://dx.doi.org/10.1007/BF01806308},
    volume = {5},
    year = {1992}
}

@techreport{Dybvig1992Writing,
    abstract = {ion in Scheme\&\#034; [4], which was mostly written before Bob\&\#039;s death, does attempt to justify the macro system and to place it within the context of other work. The companion report also contains more detail on the algorithms used by our implementation of the macro system. A complete implementation of the macro system is available, and should run in any Scheme system with the provision of a few implementation-dependent \&\#034;hooks.\&\#034; It can be obtained via \&\#034;anonymous ftp\&\#034; from iuvax.cs.indiana.edu in the directory pub/scheme/syntax-case. If you do not have ftp access, contact me and I will get the implementation to you somehow. The implementation is based on an earlier implementation by Bob and myself of the system described in an appendix to the \&\#034;Revised  4  Report on the Algorithmic Language Scheme\&\#034; [2]. The present implementation, however, is more robust and significantly more efficient. I would like to thank Carl Bruggeman for his detailed and thoughtful comments on drafts of this report, and...},
    author = {Dybvig, Kent},
    citeulike-article-id = {8040957},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.5180},
    journal = {Indiana Computer Science Department},
    institution = {Indiana Computer Science Department},
    keywords = {macros, *pljr, *pljr-macros},
    posted-at = {2010-10-18 04:01:47},
    priority = {0},
    title = {Writing Hygienic Macros in Scheme with Syntax-Case},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.5180},
    year = {1992}
}

@inproceedings{Flatt2002Composable,
    abstract = {Many macro systems, especially for Lisp and Scheme, allow macro transformers to perform general computation. Moreover, the language for implementing compile-time macro transformers is usually the same as the language for implementing run-time functions. As a side effect of this sharing, implementations tend to allow the mingling of compile-time values and run-time values, as well as values from separate compilations. Such mingling breaks programming tools that must parse code without executing it. Macro implementors avoid harmful mingling by obeying certain macro-definition protocols and by inserting phase-distinguishing annotations into the code. However, the annotations are fragile, the protocols are not enforced, and programmers can only reason about the result in terms of the compiler's implementation. MzScheme---the language of the PLT Scheme tool suite---addresses the problem through a macro system that separates compilation without sacrificing the expressiveness of macros.},
    address = {New York, NY, USA},
    author = {Flatt, Matthew},
    booktitle = {ICFP '02: Proceedings of the seventh ACM SIGPLAN international conference on Functional programming},
    citeulike-article-id = {1164},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=581478.581486},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/581478.581486},
    doi = {10.1145/581478.581486},
    keywords = {macros, *pljr, *pljr-macros},
    location = {Pittsburgh, PA, USA},
    month = {September},
    pages = {72--83},
    posted-at = {2010-10-18 06:04:12},
    priority = {0},
    publisher = {ACM},
    title = {Composable and compilable macros: you want it when?},
    url = {http://dx.doi.org/10.1145/581478.581486},
    year = {2002}
}

@inproceedings{Culpepper2004Taming,
    abstract = {Abstract. Scheme includes a simple yet powerful macro mechanism. Using macros, programmers can easily extend the language with new kinds of expressions and definitions, thus abstracting over recurring syntactic patterns. As with every other powerful language mechanism, programmers can also easily misuse macros and, to this day, broken macro definitions or macro uses pose complex debugging problems to programmers at all levels of experience. In this paper, we present a type system for taming Scheme-like macros. Specifically, we formulate a small model that captures the essential properties of Scheme-style macros. For this model, we formulate a novel type system to eliminate some of these problems, prove its soundness, and validate its pragmatic usefulness. 1 The Power of Macro Programming Over the past 20 years, the Scheme community has developed an expressive and easy-to-use standard macro system [1]. To introduce a new construct via a},
    author = {Culpepper, Ryan and Felleisen, Matthias},
    booktitle = {GPCE 2004: Proceedings of the 3rd International Conference on Generative Programming and Component Engineering},
    citeulike-article-id = {8040980},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.3056},
    keywords = {macros, *pljr, *pljr-macros},
    posted-at = {2010-10-18 04:15:04},
    priority = {0},
    title = {Taming macros},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.3056},
    year = {2004}
}

@inproceedings{Herman2008Theory,
    abstract = {Hygienic macro systems, such as Scheme's, automatically rename variables to prevent unintentional variable capture--in short, they "just work." Yet hygiene has never been formally presented as a specification rather than an algorithm. According to folklore, the definition of hygienicmacro expansion hinges on the preservation of alpha-equivalence. But the only known notion of alpha-equivalence for programs with macros depends on the results of macro expansion! We break this circularity by introducing explicit binding specifications into the syntax of macro definitions, permitting a definition of alpha-equivalence independent of expansion. We define a semantics for a first-order subset of Scheme-like macros and prove hygiene as a consequence of confluence.},
    address = {Berlin, Heidelberg},
    author = {Herman, David and Wand, Mitchell},
    booktitle = {ESOP'08/ETAPS'08: Proceedings of the Theory and practice of software, 17th European conference on Programming languages and systems},
    citeulike-article-id = {8041039},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1792884},
    isbn = {3-540-78738-0, 978-3-540-78738-9},
    keywords = {macros, *pljr, *pljr-macros},
    location = {Budapest, Hungary},
    pages = {48--62},
    posted-at = {2010-10-18 04:35:55},
    priority = {0},
    publisher = {Springer-Verlag},
    title = {A theory of hygienic macros},
    url = {http://portal.acm.org/citation.cfm?id=1792884},
    year = {2008}
}

@inproceedings{Culpepper2010Fortifying,
    abstract = {Existing macro systems force programmers to make a choice between clarity of specification and robustness. If they choose clarity, they must forgo validating significant parts of the specification and thus produce low-quality language extensions. If they choose robustness, they must write in a style that mingles the implementation with the specification and therefore obscures the latter.},
    address = {New York, NY, USA},
    author = {Culpepper, Ryan and Felleisen, Matthias},
    booktitle = {ICFP '10: Proceedings of the 15th ACM SIGPLAN international conference on Functional programming},
    citeulike-article-id = {8040963},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1863543.1863577},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1863543.1863577},
    doi = {10.1145/1863543.1863577},
    isbn = {978-1-60558-794-3},
    keywords = {macros, *pljr, *pljr-macros},
    location = {Baltimore, Maryland, USA},
    pages = {235--246},
    posted-at = {2010-10-18 04:06:09},
    priority = {0},
    publisher = {ACM},
    title = {Fortifying macros},
    url = {http://dx.doi.org/10.1145/1863543.1863577},
    year = {2010}
}

